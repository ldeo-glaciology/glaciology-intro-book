
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Working with output from general circulation models using xesmf and xgcm &#8212; Earth and Environmental Data Science</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.e8e5499552300ddf5d7adccae7cc3b70.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://earth-env-data-science.github.io/lectures/working_with_gcm_data.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dask for Parallel Computing in Python" href="dask/intro.html" />
    <link rel="prev" title="Assignment: Making Maps with Cartopy" href="../assignments/cartopy.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      <img src="../_static/eeds-logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Earth and Environmental Data Science</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   An Introduction to Earth and Environmental Data Science
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  About this Book
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../LICENSE.html">
   License for this book
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../projects.html">
   Final Projects
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The Interactive Computing Environment
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="environment/intro_to_jupyterlab.html">
   Intro to JupyterLab
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="environment/intro_to_unix.html">
   Intro to Unix
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="environment/intro_to_git.html">
   Intro to Git for Version Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assignments/files_markdown_git.html">
   Assignment: Files, Git, and Github
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="environment/python_environments.html">
   Managing Python Environments
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="environment/binder.html">
   Binder for Reproducible Research
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data.html">
   All About Data
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  The Core Python Language
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="core_python/python_fundamentals.html">
   Python Fundamentals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="core_python/functions_classes.html">
   Python Functions and Classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="core_python/organization_and_packaging.html">
   Organization and Packaging of Python Projects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assignments/python_basics_and_functions.html">
   Assignment: Basic Python
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Scientific Python Fundamentals
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basic_scipy/numpy_and_matplotlib.html">
   Numpy and Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assignments/numpy_matplotlib.html">
   Assignment 3 - Numpy and Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basic_scipy/more_matplotlib.html">
   More Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assignments/more_matplotlib.html">
   Assignment 4: More Matplotlib
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  High Level Data Analysis Frameworks
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="pandas/pandas_intro.html">
   Pandas
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="pandas/basic_pandas.html">
     Pandas Fundamentals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../assignments/basic_pandas.html">
     Assignment 5: Pandas Fundamentals with Earthquake Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pandas/pandas_groupby.html">
     Pandas: Groupby
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../assignments/pandas_groupby.html">
     Assignment 6: Pandas Groupby with Hurricane Data
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="xarray/xarray_intro.html">
   Xarray for multidimensional gridded data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="xarray/xarray.html">
     Xarray Fundamentals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../assignments/basic_xarray.html">
     Assignment 7: Xarray Fundamentals with Atmospheric Radiation Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="xarray/xarray-part2.html">
     Xarray Interpolation, Groupby, Resample, Rolling, and Coarsen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../assignments/more_xarray.html">
     Assignment: More Xarray with El Niño-Southern Oscillation (ENSO) Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="xarray/xarray_tips_and_tricks.html">
     Xarray Tips and Tricks
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Geoscience Package
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="mapping_cartopy.html">
   Maps in Scientific Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assignments/cartopy.html">
   Assignment: Making Maps with Cartopy
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Working with output from general circulation models using xesmf and xgcm
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Big Data
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="dask/intro.html">
   Dask for Parallel Computing in Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dask/dask_arrays.html">
   Computing with Dask
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lectures/working_with_gcm_data.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/earth-env-data-science/earth-env-data-science-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/earth-env-data-science/earth-env-data-science-book/issues/new?title=Issue%20on%20page%20%2Flectures/working_with_gcm_data.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/earth-env-data-science/earth-env-data-science-book/edit/master/src/lectures/working_with_gcm_data.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        
        <a class="jupyterhub-button" href="https://https://us-central1-b.gcp.pangeo.io//hub/user-redirect/git-pull?repo=https://github.com/earth-env-data-science/earth-env-data-science-book&urlpath=lab/tree/earth-env-data-science-book/src/lectures/working_with_gcm_data.ipynb&branch=master"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="../_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-is-a-general-circulation-model">
   What is a general circulation model?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-globe-divided-into-boxes">
     The globe divided into boxes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#grid-resolution">
     Grid resolution
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#part-1-model-validation-comparing-a-state-estimate-to-observations">
   Part 1: Model validation: Comparing a state estimate to observations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#considerations-for-model-validation">
     Considerations for model validation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#regridding-via-interpolation">
     Regridding via interpolation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#regridding-using-conservative-interpolation">
     Regridding using conservative interpolation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#part-2-calculating-properties-in-the-native-model-grid-using-xgcm">
   Part 2: Calculating properties in the native model grid using xgcm
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="working-with-output-from-general-circulation-models-using-xesmf-and-xgcm">
<h1>Working with output from general circulation models using xesmf and xgcm<a class="headerlink" href="#working-with-output-from-general-circulation-models-using-xesmf-and-xgcm" title="Permalink to this headline">¶</a></h1>
<p>In this lecture, we will discuss some fundamental aspects and techniques to work with the output of general circulation models.</p>
<div class="section" id="what-is-a-general-circulation-model">
<h2>What is a general circulation model?<a class="headerlink" href="#what-is-a-general-circulation-model" title="Permalink to this headline">¶</a></h2>
<p>A general circulation model (GCM) is a computer model that simulates the circulation of a fluid (e.g., the ocean or atmosphere). The model is based on a set of partial differential equations, which describe the motion of a fluid in 3D space, and integrates these forward in time.  Most fundamentally, these models use a discrete representation of the <a class="reference external" href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes Equations</a> but can include more equations to represent e.g., the thermodynamics, chemistry or biology of the coupled earth system.</p>
<div class="section" id="the-globe-divided-into-boxes">
<h3>The globe divided into boxes<a class="headerlink" href="#the-globe-divided-into-boxes" title="Permalink to this headline">¶</a></h3>
<p>Since there is no analytical solution to the full Navier-Stokes equation, modern GCMs solve them using numerical methods. They use a discretized version of the equations, which approximates them within a finite volume, or grid-cell. Each GCM splits the ocean or atmosphere into many cells, both in the horizontal and vertical.</p>
<p><img alt="gcm-schematic" src="https://www.ipcc-data.org/img/3d_gcm_structure.jpg" /></p>
<blockquote>
<div><p>Source: <a class="reference external" href="http://www.ipcc-data.org">www.ipcc-data.org</a></p>
</div></blockquote>
<p>It is numerically favorable to shift (or ‘stagger’) the grid points where the model calculates the velocity with regard to the grid point where tracer values (temperature, salinity, or others) are calculated. There are several different ways to shift these points, commonly referred to as <a class="reference external" href="https://en.wikipedia.org/wiki/Arakawa_grids">Arakawa grids</a>. Most modern ocean models use a C-Grid. Thus, this lecture will focus on this particular grid configuration.
In the C-grid, the zonal velocity <span class="math notranslate nohighlight">\(u\)</span> is located on the right side (or east face) of the tracer location and the meridional velocity <span class="math notranslate nohighlight">\(v\)</span> is located on the upper side (or north face). Similarly, the vertical velocity <span class="math notranslate nohighlight">\(w\)</span> is shifted with depth, but horizontally (when looking at it from straight above), it is on the tracer location.</p>
<p><img alt="c-grid" src="https://xgcm.readthedocs.io/en/latest/_images/grid2d_hv.svg" /></p>
<blockquote>
<div><p>Source: <a class="reference external" href="http://xgcm.readthedocs.io">xgcm.readthedocs.io</a></p>
</div></blockquote>
</div>
<div class="section" id="grid-resolution">
<h3>Grid resolution<a class="headerlink" href="#grid-resolution" title="Permalink to this headline">¶</a></h3>
<p>Discretizing the equations has consequences:</p>
<ul class="simple">
<li><p>In order to get a realistic representation of the global circulation, the size of grid cells needs to be chosen so that all relevant processes are resolved.  In reality, this usually requires too much computing power for global models and so processes that are too small to be explicitly resolved, like <a class="reference external" href="https://www.gfdl.noaa.gov/ocean-mesoscale-eddies/">mesoscale eddies</a> or <a class="reference external" href="https://www.gfdl.noaa.gov/ocean-mixing/">vertical mixing</a>, need to be carefully parameterized since they influence the large scale circulation. The following video illustrates the representation of mesoscale eddies in global models of different grid resolution. It shows the surface nutrient fields of three coupled climate models (produced by NOAA/GFDL) around the Antarctic Peninsula with increasing ocean resolution from left to right.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Video to show difference in resolution</span>
<span class="c1"># from IPython.display import HTML</span>
<span class="c1"># HTML(&#39;&lt;iframe src=&quot;https://player.vimeo.com/video/259423826&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; fullscreen&quot; allowfullscreen&gt;&lt;/iframe&gt;&#39;)</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">IFrame</span><span class="c1">#, VimeoVideo, HTML</span>
<span class="n">IFrame</span><span class="p">(</span><span class="s2">&quot;https://player.vimeo.com/video/259423826&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="s2">&quot;640&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s2">&quot;360&quot;</span><span class="p">)</span>
<span class="c1"># HTML(&#39;&lt;div style=&quot;text-align: center&quot;&gt;&lt;iframe width=&quot;640&quot;, height=&quot;360&quot; src=&quot;https://player.vimeo.com/video/259423826&quot; frameborder=&quot;4&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&#39;)</span>
<span class="c1"># VimeoVideo()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="640"
            height="360"
            src="https://player.vimeo.com/video/259423826"
            frameborder="0"
            allowfullscreen
        ></iframe>
        </div></div>
</div>
<p><strong>Nominal model resolution from left to right: 1 degree (CM2.1deg), 0.25 degree (CM2.5) and 0.1 degree (CM2.6). The left ocean model employs a parametrization for both the advective and diffusive effects of mesoscale eddies, while the middle and right model do not.</strong></p>
<blockquote>
<div><p>We will learn how to <code class="docutils literal notranslate"><span class="pre">regrid</span></code> high-resolution model fields in order to compare them to observations in the first part of this lecture.</p>
</div></blockquote>
<ul class="simple">
<li><p>While regridding is necessary to compare model output to other datasets, some calculations should be performed on the native model grid for maximum accuracy. This is usually the case when you want to derive additional quantities, like the gradient or divergence of a field. Most GCMs use a <a class="reference external" href="https://en.wikipedia.org/wiki/Curvilinear_coordinates">curvilinear grid</a> to avoid infinitely small grid cells at the North Pole. Some examples of curvilinear grids are a tripolar grid (the Arctic region is defined by two poles, placed over landmasses, see Figure below) or a cubed-sphere grid (several connected patches of curvilinear grids, see Figure below).
In most ocean models, due to these ‘warped’ coordinate systems, the boxes described are not perfectly rectangular<a class="reference external" href="https://en.wikipedia.org/wiki/Cuboid">cuboids</a>. To accurately represent the volume of the cell, we require so-called grid metrics - the distances, cell areas, and volume to calculate operators like e.g., divergence.</p></li>
</ul>
<blockquote>
<div><p>We will learn how to use <a class="reference external" href="https://xgcm.readthedocs.io/en/latest/">xgcm</a> in order to deal with computations on the raw model grid.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="part-1-model-validation-comparing-a-state-estimate-to-observations">
<h2>Part 1: Model validation: Comparing a state estimate to observations<a class="headerlink" href="#part-1-model-validation-comparing-a-state-estimate-to-observations" title="Permalink to this headline">¶</a></h2>
<p>We start by importing xarray, numpy and matplotlib as usual</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<p>The model we will be using in this lecture is the <a class="reference external" href="http://sose.ucsd.edu">Southen Ocean State Estimate (SOSE)</a>, which is available in the pangeo cloud as an <a class="reference external" href="https://pangeo-data.github.io/pangeo-datastore/master/ocean.html">intake catalogue</a>. We will just follow the <a class="reference external" href="https://pangeo-data.github.io/pangeo-datastore/master/ocean.html#collapse1-sose">instructions</a> how to load the data into our notebook and inspect the dataset.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">intake</span>
<span class="n">cat</span> <span class="o">=</span> <span class="n">intake</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="s2">&quot;https://raw.githubusercontent.com/pangeo-data/pangeo-datastore/master/intake-catalogs/ocean.yaml&quot;</span><span class="p">)</span>
<span class="n">ds_model</span> <span class="o">=</span> <span class="n">cat</span><span class="p">[</span><span class="s2">&quot;SOSE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dask</span><span class="p">()</span>
<span class="n">ds_model</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.Dataset&gt;
Dimensions:   (XC: 2160, XG: 2160, YC: 320, YG: 320, Z: 42, Zl: 42, Zp1: 43, Zu: 42, time: 438)
Coordinates:
    Depth     (YC, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    PHrefC    (Z) float32 dask.array&lt;shape=(42,), chunksize=(42,)&gt;
    PHrefF    (Zp1) float32 dask.array&lt;shape=(43,), chunksize=(43,)&gt;
  * XC        (XC) float32 0.083333336 0.25 0.4166667 ... 359.75 359.9167
  * XG        (XG) float32 5.551115e-17 0.16666667 ... 359.6667 359.83334
  * YC        (YC) float32 -77.87497 -77.7083 -77.54163 ... -24.874966 -24.7083
  * YG        (YG) float32 -77.9583 -77.79163 -77.62497 ... -24.9583 -24.791632
  * Z         (Z) float32 -5.0 -15.5 -27.0 -39.5 ... -5075.0 -5325.0 -5575.0
  * Zl        (Zl) float32 0.0 -10.0 -21.0 -33.0 ... -4950.0 -5200.0 -5450.0
  * Zp1       (Zp1) float32 0.0 -10.0 -21.0 -33.0 ... -5200.0 -5450.0 -5700.0
  * Zu        (Zu) float32 -10.0 -21.0 -33.0 -46.0 ... -5200.0 -5450.0 -5700.0
    drC       (Zp1) float32 dask.array&lt;shape=(43,), chunksize=(43,)&gt;
    drF       (Z) float32 dask.array&lt;shape=(42,), chunksize=(42,)&gt;
    dxC       (YC, XG) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    dxG       (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    dyC       (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    dyG       (YC, XG) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    hFacC     (Z, YC, XC) float32 dask.array&lt;shape=(42, 320, 2160), chunksize=(42, 320, 2160)&gt;
    hFacS     (Z, YG, XC) float32 dask.array&lt;shape=(42, 320, 2160), chunksize=(42, 320, 2160)&gt;
    hFacW     (Z, YC, XG) float32 dask.array&lt;shape=(42, 320, 2160), chunksize=(42, 320, 2160)&gt;
    iter      (time) int64 dask.array&lt;shape=(438,), chunksize=(438,)&gt;
    rA        (YC, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    rAs       (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    rAw       (YC, XG) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    rAz       (YG, XG) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
  * time      (time) datetime64[ns] 2005-01-06 2005-01-11 ... 2010-12-31
Data variables:
    ADVr_SLT  (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ADVr_TH   (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ADVx_SLT  (time, Z, YC, XG) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ADVx_TH   (time, Z, YC, XG) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ADVy_SLT  (time, Z, YG, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ADVy_TH   (time, Z, YG, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFrE_SLT  (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFrE_TH   (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFrI_SLT  (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFrI_TH   (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFxE_SLT  (time, Z, YC, XG) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFxE_TH   (time, Z, YC, XG) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFyE_SLT  (time, Z, YG, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DFyE_TH   (time, Z, YG, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    DRHODR    (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    ETAN      (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    EXFswnet  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    KPPg_SLT  (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    KPPg_TH   (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    PHIHYD    (time, Z, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    SALT      (time, Z, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    SFLUX     (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIarea    (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIatmFW   (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIatmQnt  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIdHbATC  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIdHbATO  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIdHbOCN  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIdSbATC  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIdSbOCN  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIempmr   (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIfu      (time, YC, XG) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIfv      (time, YG, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIheff    (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIhsnow   (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIsnPrcp  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SItflux   (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIuheff   (time, YC, XG) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIuice    (time, YC, XG) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIvheff   (time, YG, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    SIvice    (time, YG, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    TFLUX     (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    THETA     (time, Z, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    TOTSTEND  (time, Z, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    TOTTTEND  (time, Z, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    UVEL      (time, Z, YC, XG) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    VVEL      (time, Z, YG, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    WSLTMASS  (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    WTHMASS   (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    WVEL      (time, Zl, YC, XC) float32 dask.array&lt;shape=(438, 42, 320, 2160), chunksize=(1, 42, 320, 2160)&gt;
    oceFreez  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    oceQsw    (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    oceTAUX   (time, YC, XG) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    oceTAUY   (time, YG, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    surForcS  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
    surForcT  (time, YC, XC) float32 dask.array&lt;shape=(438, 320, 2160), chunksize=(1, 320, 2160)&gt;
</pre></div>
</div>
</div>
</div>
<p>This dataset has a lot of output variables. For this lecture we are going to focus on sea surface temperature. In the model this is represented by the surfac layer in the vertical (dimension <code class="docutils literal notranslate"><span class="pre">Z</span></code>) of the temperature dataarray <code class="docutils literal notranslate"><span class="pre">THETA</span></code>.</p>
<p>Lets create a new <code class="docutils literal notranslate"><span class="pre">sst_model</span></code> dataarray and plot the first time step.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_model</span> <span class="o">=</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">THETA</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">Z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">sst_model</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f466c068710&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_9_1.png" src="../_images/working_with_gcm_data_9_1.png" />
</div>
</div>
<p>As the name suggests, this model output is not global, but instead focusses on the Southern Ocean.
A common analysis step is model validation - comparing model output to an observation of the same variable. We will use the previously used sea surface temperature dataset.</p>
<p>We load the dataset as before, but limit the latitude dimension to exclude values in the tropics and the northern hemisphere.</p>
<blockquote>
<div><p>Note that the <code class="docutils literal notranslate"><span class="pre">lon</span></code> dimension in the dataset is given in descending order, e.g. the first value is the northernmost. You can change the order by applying <code class="docutils literal notranslate"><span class="pre">sortby('lat')</span></code>, which will reshuffle the full dataset so that <code class="docutils literal notranslate"><span class="pre">lat</span></code> values are monotonically increasing.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># xr.set_options(display_style=&#39;html&#39;) # !!! need to update xarray for this?</span>
<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.esrl.noaa.gov/psd/thredds/dodsC/Datasets/noaa.ersst.v5/sst.mnmean.nc&#39;</span>
<span class="n">ds_obs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">)</span>
<span class="c1"># restrict the obs to the southern ocean</span>
<span class="n">ds_obs</span> <span class="o">=</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">))</span>
<span class="n">ds_obs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.Dataset&gt;
Dimensions:    (lat: 32, lon: 180, nbnds: 2, time: 1990)
Coordinates:
  * lat        (lat) float64 -88.0 -86.0 -84.0 -82.0 ... -32.0 -30.0 -28.0 -26.0
  * lon        (lon) float64 0.0 2.0 4.0 6.0 8.0 ... 352.0 354.0 356.0 358.0
  * time       (time) datetime64[ns] 1854-01-01 1854-02-01 ... 2019-10-01
Dimensions without coordinates: nbnds
Data variables:
    time_bnds  (time, nbnds) float64 dask.array&lt;shape=(1990, 2), chunksize=(12, 2)&gt;
    sst        (time, lat, lon) float32 dask.array&lt;shape=(1990, 32, 180), chunksize=(12, 32, 180)&gt;
Attributes:
    climatology:                     Climatology is based on 1971-2000 SST, X...
    description:                     In situ data: ICOADS2.5 before 2007 and ...
    keywords_vocabulary:             NASA Global Change Master Directory (GCM...
    keywords:                        Earth Science &gt; Oceans &gt; Ocean Temperatu...
    instrument:                      Conventional thermometers
    source_comment:                  SSTs were observed by conventional therm...
    geospatial_lon_min:              -1.0
    geospatial_lon_max:              359.0
    geospatial_laty_max:             89.0
    geospatial_laty_min:             -89.0
    geospatial_lat_max:              89.0
    geospatial_lat_min:              -89.0
    geospatial_lat_units:            degrees_north
    geospatial_lon_units:            degrees_east
    cdm_data_type:                   Grid
    project:                         NOAA Extended Reconstructed Sea Surface ...
    original_publisher_url:          http://www.ncdc.noaa.gov
    References:                      https://www.ncdc.noaa.gov/data-access/ma...
    source:                          In situ data: ICOADS R3.0 before 2015, N...
    title:                           NOAA ERSSTv5 (in situ only)
    history:                         created 07/2017 by PSD data using NCEI&#39;s...
    institution:                     This version written at NOAA/ESRL PSD: o...
    citation:                        Huang et al, 2017: Extended Reconstructe...
    platform:                        Ship and Buoy SSTs from ICOADS R3.0 and ...
    standard_name_vocabulary:        CF Standard Name Table (v40, 25 January ...
    processing_level:                NOAA Level 4
    Conventions:                     CF-1.6, ACDD-1.3
    metadata_link:                   :metadata_link = https://doi.org/10.7289...
    creator_name:                    Boyin Huang (original)
    date_created:                    2017-06-30T12:18:00Z (original)
    product_version:                 Version 5
    creator_url_original:            https://www.ncei.noaa.gov
    license:                         No constraints on data access or use
    comment:                         SSTs were observed by conventional therm...
    summary:                         ERSST.v5 is developed based on v4 after ...
    dataset_title:                   NOAA Extended Reconstructed SST V5
    data_modified:                   2019-11-04
    DODS_EXTRA.Unlimited_Dimension:  time
</pre></div>
</div>
</div>
</div>
<p>Lets now define a new dataarray so that we have a consistent naming between the model output and observations. As before we also plot the first time step of the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_obs</span> <span class="o">=</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">sst</span>
<span class="n">sst_obs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f465431c8d0&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_13_1.png" src="../_images/working_with_gcm_data_13_1.png" />
</div>
</div>
<div class="section" id="considerations-for-model-validation">
<h3>Considerations for model validation<a class="headerlink" href="#considerations-for-model-validation" title="Permalink to this headline">¶</a></h3>
<p>Now that we have both datasets loaded, how do we approach the model validation?</p>
<p>It is always crucial to put some thought into which time periods of a model and observations are actually comparable. In this case both should be directly comparable since SOSE is a state estimate, which incorporates observations to estimate the state of the ocean at the time observations were taken (and in between). If however the model data would be from a fully coupled climate model, we would have to take e.g. long averages due to the fact that internal variability - like for instance ENSO - can not be expected to happen in the same year as observations. But since we chose a state estimate, we can actually compare the data in a single year or even month (this will save us some computing time, but if you are interested, go ahead and choose a longer averaging period below and compare the results).</p>
<p>Now select a time period that overlaps between model and observations, e.g. the year 2009 and average over the year.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_model</span> <span class="o">=</span> <span class="n">sst_model</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;2009&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
<span class="n">sst_obs</span> <span class="o">=</span> <span class="n">sst_obs</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;2009&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/srv/conda/envs/notebook/lib/python3.7/site-packages/dask/array/numpy_compat.py:38: RuntimeWarning: invalid value encountered in true_divide
  x = np.divide(x1, x2, out)
</pre></div>
</div>
</div>
</div>
<p>For later we will also rename the model dimensions <code class="docutils literal notranslate"><span class="pre">XC</span></code> and <code class="docutils literal notranslate"><span class="pre">YC</span></code> into <code class="docutils literal notranslate"><span class="pre">lon</span></code> and <code class="docutils literal notranslate"><span class="pre">lat</span></code>, so that both model and observations are named consistently.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_model</span> <span class="o">=</span> <span class="n">sst_model</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;XC&#39;</span><span class="p">:</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;YC&#39;</span><span class="p">:</span><span class="s1">&#39;lat&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>We can now plot both fields next to each other. By specifying <code class="docutils literal notranslate"><span class="pre">vmax=30</span></code> in the plot command, we ensure that both plots have the exact same colorbar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># !!! is this taught before?</span>
<span class="n">sst_obs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span> <span class="c1"># make sure to have the same colorlimit</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sst_model</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f4654183c50&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_19_1.png" src="../_images/working_with_gcm_data_19_1.png" />
</div>
</div>
<p>This looks nice and the large scale structure (colder waters near Antarctica) agree. But since temperature differs over such a wide range, it is hard to quantify the differences with the naked eye. Naturally we would want to plot the difference between both datasets.</p>
</div>
<div class="section" id="regridding-via-interpolation">
<h3>Regridding via interpolation<a class="headerlink" href="#regridding-via-interpolation" title="Permalink to this headline">¶</a></h3>
<p>There is however a major problem: Both datasets are on a different grid - the model has a much higher resolution (~ 1/5 deg) than the observations (~ 2 degree). In the model we can see signs of mesoscale eddies, even in the yearly average.</p>
<p>To compare the dataset directly they have to be on the same grid, e.g. each point of the array has to correspond to the same position.</p>
<p><em>We have 3 options to achieve this</em>:</p>
<ol class="simple">
<li><p>Regrid the lower resolution dataset (observations) onto the higher resolution dataset (model).</p></li>
<li><p>Regrid the higher resolution dataset (model) onto the lower resolution dataset (observations).</p></li>
<li><p>Define a completely new grid and regrid both datasets onto that.</p></li>
</ol>
<p>Both 1. and 2. have unique advantages and disadvantages, whereas 3. can share some or all of these, depending on whether the new grid is defined on a higher, lower or intermediate resolution compared to the two datasets.</p>
<p>Lets try both approaches and see how they compare. For this step we will use <a class="reference external" href="https://xesmf.readthedocs.io/en/latest/">xesmf</a> a very powerful geospatial regridding tool.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xesmf</span> <span class="k">as</span> <span class="nn">xe</span>
</pre></div>
</div>
</div>
</div>
<p>To regrid a dataarray with xesmf you need to execute the following steps:</p>
<ol>
<li><p>Create a target grid dataset (this can also be an existing dataset)</p>
<blockquote>
<div><p>Note: Rename the dataset appropriately. xesmf expects longitude and latitude to be labelled as <code class="docutils literal notranslate"><span class="pre">lon</span></code> and <code class="docutils literal notranslate"><span class="pre">lat</span></code> (this is the reason we renamed the model dataset previously).</p>
</div></blockquote>
</li>
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">regridder</span></code> object (using the target grid and the source dataset - e.g. the dataset that should be regridded)</p>
<blockquote>
<div><p>Note: You might have to clean existing files that the regridder might have written out using <code class="docutils literal notranslate"><span class="pre">regridder.clean_weight_file()</span></code> (this is only needed if the regridder has been previously applied, but it does not hurt to apply it just in case)</p>
</div></blockquote>
</li>
<li><p>Apply the <code class="docutils literal notranslate"><span class="pre">regridder</span></code> to a dataset, e.g. <code class="docutils literal notranslate"><span class="pre">regridder(ds)</span></code></p></li>
</ol>
<p>We will start by regridding the low resolution observations onto the high resolution model grid, by using linear interpolation in two dimensions (<code class="docutils literal notranslate"><span class="pre">bilinear</span></code>) and specifying that our domain is periodic.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regridder</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">Regridder</span><span class="p">(</span><span class="n">sst_obs</span><span class="p">,</span> <span class="n">sst_model</span><span class="p">,</span> <span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#since this is global we need to pass periodic</span>
<span class="n">regridder</span><span class="o">.</span><span class="n">clean_weight_file</span><span class="p">()</span>
<span class="n">regridder</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Create weight file: bilinear_32x180_320x2160_peri.nc
Remove file bilinear_32x180_320x2160_peri.nc
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>xESMF Regridder 
Regridding algorithm:       bilinear 
Weight filename:            bilinear_32x180_320x2160_peri.nc 
Reuse pre-computed weights? False 
Input grid shape:           (32, 180) 
Output grid shape:          (320, 2160) 
Output grid dimension name: (&#39;lat&#39;, &#39;lon&#39;) 
Periodic in longitude?      True
</pre></div>
</div>
</div>
</div>
<p>We can now apply the regridder to the observed sea surface temperature.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_obs_regridded</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">sst_obs</span><span class="p">)</span>
<span class="n">sst_obs_regridded</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray &#39;sst&#39; (lat: 320, lon: 2160)&gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.]])
Coordinates:
  * lon      (lon) float32 0.083333336 0.25 0.4166667 ... 359.75 359.9167
  * lat      (lat) float32 -77.87497 -77.7083 -77.54163 ... -24.874966 -24.7083
Attributes:
    regrid_method:  bilinear
</pre></div>
</div>
</div>
</div>
<p>You see that the size of the dimensions has increased. It is now the same as the model data. Lets see how the regridded data compares.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">sst_obs_regridded</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span> <span class="c1"># make sure to have the same colorlimit</span>
<span class="c1"># plt.ylim(-80, -24)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sst_model</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f4648031320&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_27_1.png" src="../_images/working_with_gcm_data_27_1.png" />
</div>
</div>
<p>The observations now have more datapoints and look a lot smoother, but since the values are just linearly interpolated, there is no new information on smaller scales.</p>
<p>Now lets compare both estimates by computing the difference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diff</span> <span class="o">=</span> <span class="n">sst_model</span> <span class="o">-</span> <span class="n">sst_obs_regridded</span> 
<span class="n">diff</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f4643f08320&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_29_1.png" src="../_images/working_with_gcm_data_29_1.png" />
</div>
</div>
<p>We can see that the model sea surface temperature is quite a bit different (up to 2 deg C in some places). But the comparison is hindered by a lot of smaller scale structure that stems from eddies in the model data, which are not resolved in the observations.</p>
<p>This is the major disadvantage of Method 1. from above: The comparison becomes ‘unfair’ because we are usually only interested on larger scale differences. Even if the observations would have a higher resolution, from our physical understanding we would not expect that turbulent features like ocean eddies would happen at the exact same space and time in the model as the observations.</p>
<p>So how do we solve this issue? Lets look at method 2. to compare the model and observations on a lower resolution.
We first try the exact same procedure as befor (linear interpolation), but switch the source and target datasets.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regridder</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">Regridder</span><span class="p">(</span><span class="n">sst_model</span><span class="p">,</span><span class="n">sst_obs</span><span class="p">,</span> <span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#since this is global we need to pass periodic</span>
<span class="n">regridder</span><span class="o">.</span><span class="n">clean_weight_file</span><span class="p">()</span>
<span class="n">sst_model_regridded</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">sst_model</span><span class="p">)</span>
<span class="n">sst_model_regridded</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Create weight file: bilinear_320x2160_32x180_peri.nc
Remove file bilinear_320x2160_32x180_peri.nc
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray &#39;THETA&#39; (lat: 32, lon: 180)&gt;
array([[ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       ...,
       [20.185935, 19.964374, 19.690668, ..., 20.646542, 20.335984, 20.317114],
       [20.801154, 20.477957, 20.144566, ..., 21.67011 , 21.22205 , 21.067159],
       [20.903206, 20.605169, 20.364102, ..., 21.828444, 21.537927, 21.231561]])
Coordinates:
    PHrefC   float32 49.05
    Z        float32 -5.0
    drF      float32 10.0
  * lon      (lon) float64 0.0 2.0 4.0 6.0 8.0 ... 350.0 352.0 354.0 356.0 358.0
  * lat      (lat) float64 -88.0 -86.0 -84.0 -82.0 ... -32.0 -30.0 -28.0 -26.0
Attributes:
    regrid_method:  bilinear
</pre></div>
</div>
</div>
</div>
<p>Lets compare the original observations against the regridded model data as before</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diff</span> <span class="o">=</span> <span class="n">sst_model_regridded</span> <span class="o">-</span> <span class="n">sst_obs</span>
<span class="n">diff</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f4643ebf4a8&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_33_1.png" src="../_images/working_with_gcm_data_33_1.png" />
</div>
</div>
<p>That was easy enough, but there is a problem with this approach. Using linear interpolation works very well when we ‘upsample’ (going from lower to higher resolution), since most of the interpolated points are between the wider spaced original data. If we ‘downsample’ (going from higher resolution to lower resolution), this method will only use the two nearest points to infer a new value. This means most of the high resolution source data is not taken into consideration, and small noisy features can have a disproportionate influence on the regridded data. It also implies that properties like tracer concentrations over the full domain are not necessarily conserved.</p>
<p>We can plot the original and the downsampled modeldata along a constant latitude to illustrate the problem</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_lat</span> <span class="o">=</span> <span class="o">-</span><span class="mi">46</span>
<span class="n">sst_model</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">sample_lat</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">))</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="n">sst_model_regridded</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">sample_lat</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">))</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7f4638207898&gt;]
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_35_1.png" src="../_images/working_with_gcm_data_35_1.png" />
</div>
</div>
<p>As you can see the upsampled datapoints depend highly on the position of the target grid. What we should rather do in this case is average values around the wider target grid. This can be achieved by using a different method in xesmf.</p>
</div>
<div class="section" id="regridding-using-conservative-interpolation">
<h3>Regridding using conservative interpolation<a class="headerlink" href="#regridding-using-conservative-interpolation" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">conservative</span></code> option will take an average over several grid cells to reduce the resolution of the model. This ensures that no information is discarded and that for instance adjacent positive and negative anomalies are not increasing the noise in the regridded data.</p>
<p>This method is always preferable, when moving to lower resolutions, especially when the data is not very smooth. Unfortunately this also requires some more input parameter, namely the bounding coordinates of each gridpoint (in addition to the center or tracer coordinate; see schematic in the introduction). xesmf expects those coordinates to be named <code class="docutils literal notranslate"><span class="pre">lon_b</span></code> and <code class="docutils literal notranslate"><span class="pre">lat_b</span></code>.</p>
<p>When we look carefully at the model data, these bounding coordinates are already given (as the coodinates for the <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> velocities on a staggered grid - <code class="docutils literal notranslate"><span class="pre">XC</span></code> and <code class="docutils literal notranslate"><span class="pre">YC</span></code> respectively), but xesmf requires a bounding value at each side (This model does only provides the same amount of coordinate values for both tracer and velocity points).</p>
<p>We have two options: a) Remove one of the tracer points and leave the velocity points as is, or b) add an additional coordinate value.</p>
<p>Since the model has a significantly higher resolution, we will chose the simpler way a) and just remove one tracer point, omitting one out of 10 points for the new coarse grid (which is acceptable in this case).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">modified_grid_model</span> <span class="o">=</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">XC</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">YC</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;XC&#39;</span><span class="p">:</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span>
                                                            <span class="s1">&#39;XG&#39;</span><span class="p">:</span><span class="s1">&#39;lon_b&#39;</span><span class="p">,</span>
                                                            <span class="s1">&#39;YC&#39;</span><span class="p">:</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span>
                                                            <span class="s1">&#39;YG&#39;</span><span class="p">:</span><span class="s1">&#39;lat_b&#39;</span><span class="p">})</span>

<span class="n">modified_grid_model</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.Dataset&gt;
Dimensions:   (Z: 42, Zl: 42, Zp1: 43, Zu: 42, lat: 319, lat_b: 320, lon: 2159, lon_b: 2160, time: 438)
Coordinates:
    Depth     (lat, lon) float32 dask.array&lt;shape=(319, 2159), chunksize=(319, 2159)&gt;
    PHrefC    (Z) float32 dask.array&lt;shape=(42,), chunksize=(42,)&gt;
    PHrefF    (Zp1) float32 dask.array&lt;shape=(43,), chunksize=(43,)&gt;
  * lon       (lon) float32 0.083333336 0.25 0.4166667 ... 359.58334 359.75
  * lon_b     (lon_b) float32 5.551115e-17 0.16666667 ... 359.6667 359.83334
  * lat       (lat) float32 -77.87497 -77.7083 ... -25.041632 -24.874966
  * lat_b     (lat_b) float32 -77.9583 -77.79163 ... -24.9583 -24.791632
  * Z         (Z) float32 -5.0 -15.5 -27.0 -39.5 ... -5075.0 -5325.0 -5575.0
  * Zl        (Zl) float32 0.0 -10.0 -21.0 -33.0 ... -4950.0 -5200.0 -5450.0
  * Zp1       (Zp1) float32 0.0 -10.0 -21.0 -33.0 ... -5200.0 -5450.0 -5700.0
  * Zu        (Zu) float32 -10.0 -21.0 -33.0 -46.0 ... -5200.0 -5450.0 -5700.0
    drC       (Zp1) float32 dask.array&lt;shape=(43,), chunksize=(43,)&gt;
    drF       (Z) float32 dask.array&lt;shape=(42,), chunksize=(42,)&gt;
    dxC       (lat, lon_b) float32 dask.array&lt;shape=(319, 2160), chunksize=(319, 2160)&gt;
    dxG       (lat_b, lon) float32 dask.array&lt;shape=(320, 2159), chunksize=(320, 2159)&gt;
    dyC       (lat_b, lon) float32 dask.array&lt;shape=(320, 2159), chunksize=(320, 2159)&gt;
    dyG       (lat, lon_b) float32 dask.array&lt;shape=(319, 2160), chunksize=(319, 2160)&gt;
    hFacC     (Z, lat, lon) float32 dask.array&lt;shape=(42, 319, 2159), chunksize=(42, 319, 2159)&gt;
    hFacS     (Z, lat_b, lon) float32 dask.array&lt;shape=(42, 320, 2159), chunksize=(42, 320, 2159)&gt;
    hFacW     (Z, lat, lon_b) float32 dask.array&lt;shape=(42, 319, 2160), chunksize=(42, 319, 2160)&gt;
    iter      (time) int64 dask.array&lt;shape=(438,), chunksize=(438,)&gt;
    rA        (lat, lon) float32 dask.array&lt;shape=(319, 2159), chunksize=(319, 2159)&gt;
    rAs       (lat_b, lon) float32 dask.array&lt;shape=(320, 2159), chunksize=(320, 2159)&gt;
    rAw       (lat, lon_b) float32 dask.array&lt;shape=(319, 2160), chunksize=(319, 2160)&gt;
    rAz       (lat_b, lon_b) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
  * time      (time) datetime64[ns] 2005-01-06 2005-01-11 ... 2010-12-31
Data variables:
    ADVr_SLT  (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    ADVr_TH   (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    ADVx_SLT  (time, Z, lat, lon_b) float32 dask.array&lt;shape=(438, 42, 319, 2160), chunksize=(1, 42, 319, 2160)&gt;
    ADVx_TH   (time, Z, lat, lon_b) float32 dask.array&lt;shape=(438, 42, 319, 2160), chunksize=(1, 42, 319, 2160)&gt;
    ADVy_SLT  (time, Z, lat_b, lon) float32 dask.array&lt;shape=(438, 42, 320, 2159), chunksize=(1, 42, 320, 2159)&gt;
    ADVy_TH   (time, Z, lat_b, lon) float32 dask.array&lt;shape=(438, 42, 320, 2159), chunksize=(1, 42, 320, 2159)&gt;
    DFrE_SLT  (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    DFrE_TH   (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    DFrI_SLT  (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    DFrI_TH   (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    DFxE_SLT  (time, Z, lat, lon_b) float32 dask.array&lt;shape=(438, 42, 319, 2160), chunksize=(1, 42, 319, 2160)&gt;
    DFxE_TH   (time, Z, lat, lon_b) float32 dask.array&lt;shape=(438, 42, 319, 2160), chunksize=(1, 42, 319, 2160)&gt;
    DFyE_SLT  (time, Z, lat_b, lon) float32 dask.array&lt;shape=(438, 42, 320, 2159), chunksize=(1, 42, 320, 2159)&gt;
    DFyE_TH   (time, Z, lat_b, lon) float32 dask.array&lt;shape=(438, 42, 320, 2159), chunksize=(1, 42, 320, 2159)&gt;
    DRHODR    (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    ETAN      (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    EXFswnet  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    KPPg_SLT  (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    KPPg_TH   (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    PHIHYD    (time, Z, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    SALT      (time, Z, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    SFLUX     (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIarea    (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIatmFW   (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIatmQnt  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIdHbATC  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIdHbATO  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIdHbOCN  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIdSbATC  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIdSbOCN  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIempmr   (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIfu      (time, lat, lon_b) float32 dask.array&lt;shape=(438, 319, 2160), chunksize=(1, 319, 2160)&gt;
    SIfv      (time, lat_b, lon) float32 dask.array&lt;shape=(438, 320, 2159), chunksize=(1, 320, 2159)&gt;
    SIheff    (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIhsnow   (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIsnPrcp  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SItflux   (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    SIuheff   (time, lat, lon_b) float32 dask.array&lt;shape=(438, 319, 2160), chunksize=(1, 319, 2160)&gt;
    SIuice    (time, lat, lon_b) float32 dask.array&lt;shape=(438, 319, 2160), chunksize=(1, 319, 2160)&gt;
    SIvheff   (time, lat_b, lon) float32 dask.array&lt;shape=(438, 320, 2159), chunksize=(1, 320, 2159)&gt;
    SIvice    (time, lat_b, lon) float32 dask.array&lt;shape=(438, 320, 2159), chunksize=(1, 320, 2159)&gt;
    TFLUX     (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    THETA     (time, Z, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    TOTSTEND  (time, Z, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    TOTTTEND  (time, Z, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    UVEL      (time, Z, lat, lon_b) float32 dask.array&lt;shape=(438, 42, 319, 2160), chunksize=(1, 42, 319, 2160)&gt;
    VVEL      (time, Z, lat_b, lon) float32 dask.array&lt;shape=(438, 42, 320, 2159), chunksize=(1, 42, 320, 2159)&gt;
    WSLTMASS  (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    WTHMASS   (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    WVEL      (time, Zl, lat, lon) float32 dask.array&lt;shape=(438, 42, 319, 2159), chunksize=(1, 42, 319, 2159)&gt;
    oceFreez  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    oceQsw    (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    oceTAUX   (time, lat, lon_b) float32 dask.array&lt;shape=(438, 319, 2160), chunksize=(1, 319, 2160)&gt;
    oceTAUY   (time, lat_b, lon) float32 dask.array&lt;shape=(438, 320, 2159), chunksize=(1, 320, 2159)&gt;
    surForcS  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
    surForcT  (time, lat, lon) float32 dask.array&lt;shape=(438, 319, 2159), chunksize=(1, 319, 2159)&gt;
</pre></div>
</div>
</div>
</div>
<p>For the observations we choose method b.</p>
<p>Since the data are given on a regular 2 by 2 degree grid, we construct the bounding coordinates by subtracting 1 deg of the center point and adding another point at the end.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lon_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ds_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">lat_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ds_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">modified_grid_obs</span> <span class="o">=</span> <span class="n">ds_obs</span>
<span class="n">modified_grid_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lon_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">lon_boundary</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lon_b&#39;</span><span class="p">])</span>
<span class="n">modified_grid_obs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;lat_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">lat_boundary</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat_b&#39;</span><span class="p">])</span>
<span class="n">modified_grid_obs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.Dataset&gt;
Dimensions:    (lat: 32, lat_b: 33, lon: 180, lon_b: 181, nbnds: 2, time: 1990)
Coordinates:
  * lat        (lat) float64 -88.0 -86.0 -84.0 -82.0 ... -32.0 -30.0 -28.0 -26.0
  * lon        (lon) float64 0.0 2.0 4.0 6.0 8.0 ... 352.0 354.0 356.0 358.0
  * time       (time) datetime64[ns] 1854-01-01 1854-02-01 ... 2019-10-01
  * lon_b      (lon_b) float64 -1.0 1.0 3.0 5.0 7.0 ... 353.0 355.0 357.0 359.0
  * lat_b      (lat_b) float64 -89.0 -87.0 -85.0 -83.0 ... -29.0 -27.0 -25.0
Dimensions without coordinates: nbnds
Data variables:
    time_bnds  (time, nbnds) float64 dask.array&lt;shape=(1990, 2), chunksize=(12, 2)&gt;
    sst        (time, lat, lon) float32 dask.array&lt;shape=(1990, 32, 180), chunksize=(12, 32, 180)&gt;
Attributes:
    climatology:                     Climatology is based on 1971-2000 SST, X...
    description:                     In situ data: ICOADS2.5 before 2007 and ...
    keywords_vocabulary:             NASA Global Change Master Directory (GCM...
    keywords:                        Earth Science &gt; Oceans &gt; Ocean Temperatu...
    instrument:                      Conventional thermometers
    source_comment:                  SSTs were observed by conventional therm...
    geospatial_lon_min:              -1.0
    geospatial_lon_max:              359.0
    geospatial_laty_max:             89.0
    geospatial_laty_min:             -89.0
    geospatial_lat_max:              89.0
    geospatial_lat_min:              -89.0
    geospatial_lat_units:            degrees_north
    geospatial_lon_units:            degrees_east
    cdm_data_type:                   Grid
    project:                         NOAA Extended Reconstructed Sea Surface ...
    original_publisher_url:          http://www.ncdc.noaa.gov
    References:                      https://www.ncdc.noaa.gov/data-access/ma...
    source:                          In situ data: ICOADS R3.0 before 2015, N...
    title:                           NOAA ERSSTv5 (in situ only)
    history:                         created 07/2017 by PSD data using NCEI&#39;s...
    institution:                     This version written at NOAA/ESRL PSD: o...
    citation:                        Huang et al, 2017: Extended Reconstructe...
    platform:                        Ship and Buoy SSTs from ICOADS R3.0 and ...
    standard_name_vocabulary:        CF Standard Name Table (v40, 25 January ...
    processing_level:                NOAA Level 4
    Conventions:                     CF-1.6, ACDD-1.3
    metadata_link:                   :metadata_link = https://doi.org/10.7289...
    creator_name:                    Boyin Huang (original)
    date_created:                    2017-06-30T12:18:00Z (original)
    product_version:                 Version 5
    creator_url_original:            https://www.ncei.noaa.gov
    license:                         No constraints on data access or use
    comment:                         SSTs were observed by conventional therm...
    summary:                         ERSST.v5 is developed based on v4 after ...
    dataset_title:                   NOAA Extended Reconstructed SST V5
    data_modified:                   2019-11-04
    DODS_EXTRA.Unlimited_Dimension:  time
</pre></div>
</div>
</div>
</div>
<p>Now we can create a conservative <code class="docutils literal notranslate"><span class="pre">regridder</span></code> by passing the modified grids and the method <code class="docutils literal notranslate"><span class="pre">conservative</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regridder</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">Regridder</span><span class="p">(</span><span class="n">modified_grid_model</span><span class="p">,</span> <span class="n">modified_grid_obs</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">)</span> <span class="c1">#since this is global we need to pass periodic</span>
<span class="n">regridder</span><span class="o">.</span><span class="n">clean_weight_file</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Create weight file: conservative_319x2159_32x180.nc
Remove file conservative_319x2159_32x180.nc
</pre></div>
</div>
</div>
</div>
<p>We then apply this new regridder to the model again. Note that we have to cut one data point of again, as done above for the full dataset.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst_model_regridded_cons</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">sst_model</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">sst_model_regridded_cons</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/srv/conda/envs/notebook/lib/python3.7/site-packages/xesmf/smm.py:70: UserWarning: Input array is not C_CONTIGUOUS. Will affect performance.
  warnings.warn(&quot;Input array is not C_CONTIGUOUS. &quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray &#39;THETA&#39; (lat: 32, lon: 180)&gt;
array([[ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      , ...,  0.      ,  0.      ,  0.      ],
       ...,
       [18.509935, 19.955008, 19.740049, ..., 20.661682, 20.400264, 20.323238],
       [19.04155 , 20.459897, 20.165475, ..., 21.616568, 21.226791, 21.009231],
       [19.162298, 20.607543, 20.363888, ..., 21.796622, 21.500974, 21.201145]])
Coordinates:
    PHrefC   float32 49.05
    Z        float32 -5.0
    drF      float32 10.0
  * lon      (lon) float64 0.0 2.0 4.0 6.0 8.0 ... 350.0 352.0 354.0 356.0 358.0
  * lat      (lat) float64 -88.0 -86.0 -84.0 -82.0 ... -32.0 -30.0 -28.0 -26.0
Attributes:
    regrid_method:  conservative
</pre></div>
</div>
</div>
</div>
<p>Now we can compare the difference between the datasets using both the interpolation and conservative method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">sst_model_regridded</span> <span class="o">-</span> <span class="n">sst_obs</span>
<span class="n">diff</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">sst_model_regridded_cons</span> <span class="o">-</span> <span class="n">sst_obs</span>
<span class="n">diff</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.QuadMesh at 0x7f464348bb38&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_46_1.png" src="../_images/working_with_gcm_data_46_1.png" />
</div>
</div>
<p>As expected the downsampling (regridding to lower resolution) via interpolation shows more noise. But even in the conservative regridding case there are still many alternating positive and negative anomalies, indicative of the fact that the observations so not resolve features down to the scale of the grid. This is a common issue with observational datasets, which have to use smoothing techniques to aquire a gridded dataset from point measurements.</p>
<p>So lastly we will conservatively regrid both datasets to an even coarser resolution (Method 3.) to alleviate some of this problematic.</p>
<p>To do this we define a coarse global grid using <code class="docutils literal notranslate"><span class="pre">xesmf.util.grid_global</span></code> and cut it appropriately (remember to leave the bounding coordinates <code class="docutils literal notranslate"><span class="pre">lon_b</span></code> and <code class="docutils literal notranslate"><span class="pre">lat_b</span></code> one element longer).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coarse_grid</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">grid_global</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">y_b</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">17</span><span class="p">))</span>
<span class="n">coarse_grid</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.Dataset&gt;
Dimensions:  (x: 72, x_b: 73, y: 16, y_b: 17)
Coordinates:
    lon      (y, x) float64 -177.5 -172.5 -167.5 -162.5 ... 167.5 172.5 177.5
    lat      (y, x) float64 -87.5 -87.5 -87.5 -87.5 ... -12.5 -12.5 -12.5 -12.5
    lon_b    (y_b, x_b) int64 -180 -175 -170 -165 -160 ... 160 165 170 175 180
    lat_b    (y_b, x_b) int64 -90 -90 -90 -90 -90 -90 ... -10 -10 -10 -10 -10
Dimensions without coordinates: x, x_b, y, y_b
Data variables:
    *empty*
</pre></div>
</div>
</div>
</div>
<p>Now we define two new regridders and create dataarrays like before.
First with the modified model grid and the new coarse grid:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regridder</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">Regridder</span><span class="p">(</span><span class="n">modified_grid_model</span><span class="p">,</span> <span class="n">coarse_grid</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">)</span> <span class="c1">#since this is global we need to pass periodic</span>
<span class="n">regridder</span><span class="o">.</span><span class="n">clean_weight_file</span><span class="p">()</span>
<span class="n">sst_coarse_model</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">sst_model</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Create weight file: conservative_319x2159_16x72.nc
Remove file conservative_319x2159_16x72.nc
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/srv/conda/envs/notebook/lib/python3.7/site-packages/xesmf/smm.py:70: UserWarning: Input array is not C_CONTIGUOUS. Will affect performance.
  warnings.warn(&quot;Input array is not C_CONTIGUOUS. &quot;
</pre></div>
</div>
</div>
</div>
<p>Then with the modified model grid and the new coarse grid:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regridder</span> <span class="o">=</span> <span class="n">xe</span><span class="o">.</span><span class="n">Regridder</span><span class="p">(</span><span class="n">modified_grid_obs</span><span class="p">,</span> <span class="n">coarse_grid</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">)</span> <span class="c1">#since this is global we need to pass periodic</span>
<span class="n">regridder</span><span class="o">.</span><span class="n">clean_weight_file</span><span class="p">()</span>
<span class="n">sst_coarse_obs</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">sst_obs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Create weight file: conservative_32x180_16x72.nc
Remove file conservative_32x180_16x72.nc
</pre></div>
</div>
</div>
</div>
<p>As a final step we visualize all four comparisons next to each other usign a Stereographic projection of the South Pole:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cartopy.crs</span> <span class="k">as</span> <span class="nn">ccrs</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axarr</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span><span class="n">ccrs</span><span class="o">.</span><span class="n">SouthPolarStereo</span><span class="p">()},</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>

<span class="k">for</span> <span class="n">ds</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">sst_model</span> <span class="o">-</span> <span class="n">sst_obs_regridded</span><span class="p">,</span> <span class="n">sst_model_regridded</span> <span class="o">-</span> <span class="n">sst_obs</span><span class="p">,</span> <span class="n">sst_model_regridded_cons</span> <span class="o">-</span> <span class="n">sst_obs</span><span class="p">,</span> <span class="n">sst_coarse_model</span> <span class="o">-</span> <span class="n">sst_coarse_obs</span><span class="p">],</span>
                  <span class="n">axarr</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_extent</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">],</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">coastlines</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/working_with_gcm_data_55_0.png" src="../_images/working_with_gcm_data_55_0.png" />
</div>
</div>
<p>Ultimately which method you use will depend on the particular use case. Before regridding, carefully inspect your datasets and think of what you want to achieve:</p>
<ul class="simple">
<li><p>Are both datasets of a similar resolution and relatively smooth? Then using linear interpolation should be acceptable and is by far the easiest way to compare the datasets.</p></li>
<li><p>Is the goal of the comparison to evaluate differences on larger scales than the grid scale? Then create a coarser grid and interpolate conservatively to gain a larger scale perspective without getting distracted by smaller scale features.</p></li>
</ul>
</div>
</div>
<div class="section" id="part-2-calculating-properties-in-the-native-model-grid-using-xgcm">
<h2>Part 2: Calculating properties in the native model grid using xgcm<a class="headerlink" href="#part-2-calculating-properties-in-the-native-model-grid-using-xgcm" title="Permalink to this headline">¶</a></h2>
<p>For maximum accuracy it is always preferrable to calculate properties in the closest way possible to the model code, which at the least means executing calculations on the native grid. For comparison you can then regrid properties afterwards. To demonstrate how to do this we now calculate the meridional sea surface temperature gradient for the SOSE output.</p>
<p>For these sort of calculations we use <a class="reference external" href="https://xgcm.readthedocs.io/en/latest/index.html">xgcm</a>, which helps us to deal with the staggered grids that models use:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xgcm</span> <span class="kn">import</span> <span class="n">Grid</span>
</pre></div>
</div>
</div>
</div>
<p>in order to work with xgcm we have to create a <code class="docutils literal notranslate"><span class="pre">Grid</span></code> object which ‘understands’ which coordinates of a dataset are representing the various staggered grid positions.</p>
<p>But first we need to check quickly how the model grid is designed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ds_model</span><span class="o">.</span><span class="n">XC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">XG</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds_model</span><span class="o">.</span><span class="n">YC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">YG</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray ()&gt;
array(False)
Coordinates:
    XC       float32 0.083333336
    XG       float32 5.551115e-17
&lt;xarray.DataArray ()&gt;
array(False)
Coordinates:
    YC       float32 -77.87497
    YG       float32 -77.9583
</pre></div>
</div>
</div>
</div>
<p>We can see that for the first datapoint of the dataset, the ‘grid coordinates’ (<code class="docutils literal notranslate"><span class="pre">XG</span></code> and <code class="docutils literal notranslate"><span class="pre">YG</span></code>) have smaller values than the ‘tracer coordinates’ (<code class="docutils literal notranslate"><span class="pre">XC</span></code> and <code class="docutils literal notranslate"><span class="pre">YC</span></code>). This means that for both <code class="docutils literal notranslate"><span class="pre">axes</span></code> (each axis decribes a logical direction and both tracer and grid coordinates), the tracer coordinate is at the center and the grid coordinate is on the left (this can be on the right for some model setups; thus, carefull checking beforehand is always recommended).</p>
<p>With this information, we can now construct the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> object and configure it properly (this step is only required once for a single grid).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">ds_model</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="s1">&#39;XC&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;XG&#39;</span><span class="p">},</span>
                    <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="s1">&#39;YC&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;YG&#39;</span><span class="p">}})</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grid</span></code> object can now be used to apply various operations on the data variables of the dataset. Most GCMs calculate all properties by using simple differences and interpolation between neighboring cells.</p>
<p>We first select the surface layer of temperature and average over year 2009.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sst</span> <span class="o">=</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">THETA</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">Z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="s1">&#39;2009&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In order to compute the meridional gradient of sea surface temperature, we have to simply compute the finite difference along axis <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">deltay_sst</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sst</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="n">deltay_sst</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray &#39;sub-9563c8ac51aadebd24c532c2db11db98&#39; (YG: 320, XC: 2160)&gt;
dask.array&lt;shape=(320, 2160), dtype=float32, chunksize=(1, 2160)&gt;
Coordinates:
  * YG       (YG) float32 -77.9583 -77.79163 -77.62497 ... -24.9583 -24.791632
  * XC       (XC) float32 0.083333336 0.25 0.4166667 ... 359.75 359.9167
</pre></div>
</div>
</div>
</div>
<p>If you look carefully, you see that the <code class="docutils literal notranslate"><span class="pre">Y</span></code> dimension has been shifted, from <code class="docutils literal notranslate"><span class="pre">YC</span></code> to <code class="docutils literal notranslate"><span class="pre">YG</span></code>. The gradient is defined on the cell face or <span class="math notranslate nohighlight">\(v\)</span> velocity point. This is however just a difference between cells. To derive the gradient in the y direction in physical units <code class="docutils literal notranslate"><span class="pre">degC/m</span></code>, we need to divide the array by the distance along the <code class="docutils literal notranslate"><span class="pre">Y</span></code> axes between adjacent tracer points <code class="docutils literal notranslate"><span class="pre">dyC</span></code> , which itself is located at the <span class="math notranslate nohighlight">\(v\)</span> velocity point.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dsst_dy</span> <span class="o">=</span> <span class="n">deltay_sst</span> <span class="o">/</span> <span class="n">ds_model</span><span class="o">.</span><span class="n">dyC</span>
<span class="n">dsst_dy</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;xarray.DataArray (YG: 320, XC: 2160)&gt;
dask.array&lt;shape=(320, 2160), dtype=float32, chunksize=(1, 2160)&gt;
Coordinates:
  * YG       (YG) float32 -77.9583 -77.79163 -77.62497 ... -24.9583 -24.791632
  * XC       (XC) float32 0.083333336 0.25 0.4166667 ... 359.75 359.9167
    dxG      (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    dyC      (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
    rAs      (YG, XC) float32 dask.array&lt;shape=(320, 2160), chunksize=(320, 2160)&gt;
</pre></div>
</div>
</div>
</div>
<p>Now lets select the surface layer and the first timestep and plot the results</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">SouthPolarStereo</span><span class="p">())</span>
<span class="n">dsst_dy</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">coastlines</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;cartopy.mpl.feature_artist.FeatureArtist at 0x7f46382c17f0&gt;
</pre></div>
</div>
<img alt="../_images/working_with_gcm_data_70_1.png" src="../_images/working_with_gcm_data_70_1.png" />
</div>
</div>
<p>The meridional gradient is positive over the whole domain (temperature is increasing towards the equator), as might be expected. The stronges gradient is associated with the boundary between the retroflection of the warm <a class="reference external" href="https://en.wikipedia.org/wiki/Agulhas_Current">Agulhas current</a> and the cold waters of the <a class="reference external" href="https://en.wikipedia.org/wiki/Antarctic_Circumpolar_Current">Antarctic Circumpolar Current</a> in the Indian Ocean sector.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lectures"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="../assignments/cartopy.html" title="previous page">Assignment: Making Maps with Cartopy</a>
    <a class='right-next' id="next-link" href="dask/intro.html" title="next page">Dask for Parallel Computing in Python</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Ryan Abernathey<br/>
        
            &copy; Copyright 2016-2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>